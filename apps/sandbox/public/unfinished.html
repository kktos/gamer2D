<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Canvas Layout DSL</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }
       
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
        }
       
        h1 {
            color: #4a5568;
            text-align: center;
            margin-bottom: 30px;
            font-size: 2.5rem;
            font-weight: 300;
        }
       
        .editor-section {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 30px;
        }
       
        .editor-panel {
            background: #f8fafc;
            border-radius: 12px;
            padding: 20px;
            border: 2px solid #e2e8f0;
        }
       
        h3 {
            color: #2d3748;
            margin-top: 0;
            margin-bottom: 15px;
            font-size: 1.2rem;
        }
       
        textarea {
            width: 100%;
            height: 400px;
            border: 1px solid #cbd5e0;
            border-radius: 8px;
            padding: 15px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            resize: vertical;
            background: white;
            transition: border-color 0.3s ease;
        }
       
        textarea:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }
       
        .controls {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            align-items: center;
        }
       
        button {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.3s ease;
            font-size: 14px;
        }
       
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.3);
        }
       
        button:active {
            transform: translateY(0);
        }
       
        .play-btn {
            background: linear-gradient(135deg, #48bb78, #38a169);
        }
       
        .pause-btn {
            background: linear-gradient(135deg, #ed8936, #dd6b20);
        }
       
        .canvas-container {
            text-align: center;
            background: #f8fafc;
            border-radius: 12px;
            padding: 20px;
            border: 2px solid #e2e8f0;
        }
       
        canvas {
            border: 2px solid #cbd5e0;
            border-radius: 8px;
            background: white;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }
       
        .error {
            background: #fed7d7;
            color: #c53030;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            border-left: 4px solid #e53e3e;
        }
       
        .success {
            background: #c6f6d5;
            color: #22543d;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            border-left: 4px solid #38a169;
        }
       
        .syntax-guide {
            background: #edf2f7;
            padding: 20px;
            border-radius: 12px;
            margin-top: 20px;
            border: 2px solid #e2e8f0;
            max-height: 600px;
            overflow-y: auto;
        }
       
        .syntax-guide h4 {
            color: #2d3748;
            margin-top: 20px;
            margin-bottom: 10px;
            font-size: 1.1rem;
        }
       
        .syntax-guide code {
            background: #f1f5f9;
            padding: 2px 6px;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            color: #4a5568;
        }
       
        .example {
            background: #f7fafc;
            border-left: 4px solid #667eea;
            padding: 15px;
            margin: 10px 0;
            border-radius: 0 8px 8px 0;
        }
       
        .feature-new {
            background: linear-gradient(135deg, #ffeaa7, #fdcb6e);
            color: #2d3436;
            padding: 3px 8px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: bold;
            margin-left: 10px;
        }
       
        @media (max-width: 768px) {
            .editor-section {
                grid-template-columns: 1fr;
            }
           
            .controls {
                justify-content: center;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Advanced Canvas Layout DSL</h1>
       
        <div class="editor-section">
            <div class="editor-panel">
                <h3>DSL Code</h3>
                <textarea id="dslInput" placeholder="Enter your advanced canvas layout description here...">// Canvas with variables and expressions
$width = 800
$height = 600
$centerX = $width / 2
$centerY = $height / 2

canvas $width x $height {
  layer background {
    rect sky at 0, 0 size $width x 300 color #87ceeb
    rect ground at 0, 300 size $width x ($height - 300) color #90ee90
  }
 
  layer objects {
    sprite player at ($centerX - 100), 400 size 32 x 32 color #ff6b6b
      animate move from ($centerX - 100), 400 to ($centerX + 100), 400 duration 3s repeat
      animate fade from 1 to 0.5 duration 2s alternate
   
    sprite enemy at ($width - 50), 350 size 24 x 24 color #ff8e53
      animate rotate from 0 to 360 duration 2s repeat
   
    text "Dynamic Scene!" at $centerX, 50 font 32px color #2d3436
      animate bounce amplitude 10 duration 1s repeat
  }
 
  layer ui {
    rect panel at 10, 10 size 200 x 80 color rgba(0,0,0,0.7) stroke #fff
    text "Health: 100%" at 20, 35 font 14px color #00ff00
    text "Score: 1250" at 20, 55 font 14px color #ffff00
  }
}</textarea>
            </div>
           
            <div class="editor-panel">
                <h3>Parsed Structure</h3>
                <textarea id="parsedOutput" readonly placeholder="Parsed structure will appear here..."></textarea>
            </div>
        </div>
       
        <div class="controls">
            <button onclick="parseAndRender()">Parse & Render</button>
            <button id="playBtn" onclick="toggleAnimation()" class="play-btn">▶ Play Animation</button>
            <button onclick="loadExample(1)">Game Scene</button>
            <button onclick="loadExample(2)">UI Layout</button>
            <button onclick="loadExample(3)">Complex Animation</button>
            <button onclick="clearCanvas()">Clear</button>
        </div>
       
        <div id="messages"></div>
       
        <div class="canvas-container">
            <h3>Rendered Canvas</h3>
            <canvas id="canvas" width="800" height="600"></canvas>
        </div>
       
        <div class="syntax-guide">
            <h3>Advanced DSL Syntax Guide</h3>
           
            <h4>Variables <span class="feature-new">NEW</span></h4>
            <div class="example">
                <code>$variableName = value</code> - Define variables<br>
                <code>$variableName = expression</code> - Variables with expressions<br>
                <code>$width = 800</code><br>
                <code>$centerX = $width / 2</code>
            </div>

            <h4>Comments <span class="feature-new">NEW</span></h4>
            <div class="example">
                <code>// This is a line comment</code>
            </div>

            <h4>Expressions <span class="feature-new">NEW</span></h4>
            <div class="example">
                <code>($width - 100)</code> - Arithmetic expressions<br>
                <code>$centerX + 50</code> - Variable references<br>
                <code>800 / 2</code> - Simple math operations<br>
                Operators: <code>+, -, *, /, (, )</code>
            </div>
           
            <h4>Canvas & Layers</h4>
            <div class="example">
                <code>canvas WIDTHxHEIGHT { ... }</code><br>
                <code>layer NAME { ... }</code> - Group elements into layers for better organization
            </div>
           
            <h4>Positioning with Expressions</h4>
            <div class="example">
                <code>at X, Y</code> - Position with expressions<br>
                <code>at ($centerX - 100), 400</code> - Using variables and math<br>
                <code>at center, center</code> - Named positions<br>
                <code>at (center - 50), (center + 100)</code> - Named positions with offsets
            </div>
           
            <h4>Animations</h4>
            <div class="example">
                <code>animate move from X1,Y1 to X2,Y2 duration Ns [repeat] [alternate]</code><br>
                <code>animate fade from ALPHA1 to ALPHA2 duration Ns [repeat] [alternate]</code><br>
                <code>animate rotate from DEG1 to DEG2 duration Ns [repeat] [alternate]</code><br>
                <code>animate scale from SCALE1 to SCALE2 duration Ns [repeat] [alternate]</code><br>
                <code>animate bounce amplitude PIXELS duration Ns [repeat]</code><br>
                <code>animate pulse from SIZE1 to SIZE2 duration Ns [repeat] [alternate]</code>
            </div>
           
            <h4>Elements</h4>
            <div class="example">
                <code>sprite NAME at POSITION size WxH color COLOR [animations...]</code><br>
                <code>text "STRING" at POSITION font SIZEpx color COLOR [animations...]</code><br>
                <code>rect NAME at POSITION size WxH color COLOR [stroke STROKE_COLOR] [animations...]</code><br>
                <code>image NAME at POSITION size WxH src "URL" [animations...]</code>
            </div>
        </div>
    </div>

    <script>
        // Token types
        const TokenType = {
            IDENTIFIER: 1,
            VARIABLE: 2,
            NUMBER: 3,
            STRING: 4,
            COLOR: 5,
            OPERATOR: 6,
            PUNCTUATION: 7,
            COMMENT: 8,
            EOF: 9
        };

        // Improved Tokenizer
        class Tokenizer {
            constructor(input) {
                this.input = input;
                this.position = 0;
                this.line = 1;
                this.column = 1;
            }

            tokenize() {
                const tokens = [];
                
                while (this.position < this.input.length) {
                    this.skipWhitespace();
                    
                    if (this.position >= this.input.length) break;
                    
                    // Skip comments
                    if (this.peek() === '/' && this.peek(1) === '/') {
                        this.skipComment();
                        continue;
                    }
                    
                    const token = this.nextToken();
                    if (token && token.type !== TokenType.COMMENT) {
                        tokens.push(token);
                    }
                }
                
                tokens.push({ type: TokenType.EOF, value: null, line: this.line, column: this.column });
                return tokens;
            }

            peek(offset = 0) {
                const pos = this.position + offset;
                return pos < this.input.length ? this.input[pos] : null;
            }

            advance() {
                if (this.position < this.input.length) {
                    if (this.input[this.position] === '\n') {
                        this.line++;
                        this.column = 1;
                    } else {
                        this.column++;
                    }
                    this.position++;
                }
            }

            skipWhitespace() {
                while (this.position < this.input.length && /\s/.test(this.input[this.position])) {
                    this.advance();
                }
            }

            skipComment() {
                while (this.position < this.input.length && this.input[this.position] !== '\n') {
                    this.advance();
                }
            }

            nextToken() {
                const char = this.peek();
                
                if (!char) return null;

                // Variables
                if (char === '$') {
                    return this.readVariable();
                }

                // Numbers (including decimals)
                if (/\d/.test(char)) {
                    return this.readNumber();
                }

                // Strings
                if (char === '"') {
                    return this.readString();
                }

                // Colors
                if (char === '#') {
                    return this.readColor();
                }

                // RGBA colors
                if (char === 'r' && this.input.substr(this.position, 4) === 'rgba') {
                    return this.readRGBA();
                }

                // Operators
                if ('+-*/()'.includes(char)) {
                    const token = { type: TokenType.OPERATOR, value: char, line: this.line, column: this.column };
                    this.advance();
                    return token;
                }

                // Punctuation
                if ('{},:='.includes(char)) {
                    const token = { type: TokenType.PUNCTUATION, value: char, line: this.line, column: this.column };
                    this.advance();
                    return token;
                }

                // Special case for 'x' in dimensions
                // if (char === 'x' && /\d/.test(this.peek(-1)) && /\d/.test(this.peek(1))) {
                //     const token = { type: TokenType.OPERATOR, value: 'x', line: this.line, column: this.column };
                //     this.advance();
                //     return token;
                // }

                // Identifiers
                if (/[a-zA-Z_]/.test(char)) {
                    return this.readIdentifier();
                }

                // Unknown character - skip it
                this.advance();
                return null;
            }

            readVariable() {
                const start = this.position;
                const startColumn = this.column;
                this.advance(); // skip $
                
                while (this.position < this.input.length && /[a-zA-Z0-9_]/.test(this.peek())) {
                    this.advance();
                }
                
                const value = this.input.substring(start, this.position);
                return { type: TokenType.VARIABLE, value, line: this.line, column: startColumn };
            }

            readNumber() {
                const start = this.position;
                const startColumn = this.column;
                
                while (this.position < this.input.length && /[\d.]/.test(this.peek())) {
                    this.advance();
                }
                
                const value = this.input.substring(start, this.position);
                return { type: TokenType.NUMBER, value: parseFloat(value), line: this.line, column: startColumn };
            }

            readString() {
                const start = this.position;
                const startColumn = this.column;
                this.advance(); // skip opening quote
                
                while (this.position < this.input.length && this.peek() !== '"') {
                    this.advance();
                }
                
                if (this.peek() === '"') {
                    this.advance(); // skip closing quote
                }
                
                const value = this.input.substring(start, this.position);
                return { type: TokenType.STRING, value, line: this.line, column: startColumn };
            }

            readColor() {
                const start = this.position;
                const startColumn = this.column;
                this.advance(); // skip #
                
                while (this.position < this.input.length && /[a-fA-F0-9]/.test(this.peek())) {
                    this.advance();
                }
                
                const value = this.input.substring(start, this.position);
                return { type: TokenType.COLOR, value, line: this.line, column: startColumn };
            }

            readRGBA() {
                const start = this.position;
                const startColumn = this.column;
                
                // Read until closing parenthesis
                while (this.position < this.input.length && this.peek() !== ')') {
                    this.advance();
                }
                
                if (this.peek() === ')') {
                    this.advance();
                }
                
                const value = this.input.substring(start, this.position);
                return { type: TokenType.COLOR, value, line: this.line, column: startColumn };
            }

            readIdentifier() {
                const start = this.position;
                const startColumn = this.column;
                
                while (this.position < this.input.length && /[a-zA-Z0-9_]/.test(this.peek())) {
                    this.advance();
                }
                
                const value = this.input.substring(start, this.position);
                return { type: TokenType.IDENTIFIER, value, line: this.line, column: startColumn };
            }
        }

        // Expression Parser
        class ExpressionParser {
            constructor(tokens, variables = {}) {
                this.tokens = tokens;
                this.current = 0;
                this.variables = variables;
                this.canvasWidth = 800;
                this.canvasHeight = 600;
            }

            setCanvasSize(width, height) {
                this.canvasWidth = width;
                this.canvasHeight = height;
            }

            parseExpression() {
                return this.parseAddition();
            }

            parseAddition() {
                let left = this.parseMultiplication();
                
                while (this.match(TokenType.OPERATOR, '+') || this.match(TokenType.OPERATOR, '-')) {
                    const operator = this.previous().value;
                    const right = this.parseMultiplication();
                    left = operator === '+' ? left + right : left - right;
                }
                
                return left;
            }

            parseMultiplication() {
                let left = this.parsePrimary();
                
                while (this.match(TokenType.OPERATOR, '*') || this.match(TokenType.OPERATOR, '/') ) {
                    const operator = this.previous().value;
                    const right = this.parsePrimary();
                    if (operator === '*') {
                        left = left * right;
                    } else {
                        left = left / right;
                    }
                }
                
                return left;
            }

            parsePrimary() {
                if (this.match(TokenType.NUMBER)) {
                    return this.previous().value;
                }

                if (this.match(TokenType.VARIABLE)) {
                    const varName = this.previous().value;
                    if (this.variables.hasOwnProperty(varName)) {
                        return this.variables[varName];
                    }
                    throw new Error(`Undefined variable: ${varName}`);
                }

                if (this.match(TokenType.IDENTIFIER)) {
                    const identifier = this.previous().value;
                    // Handle named positions
                    switch (identifier) {
                        case 'center':
                            return this.canvasWidth / 2; // Default to center X, context-dependent
                        case 'left':
                            return 0;
                        case 'right':
                            return this.canvasWidth;
                        case 'top':
                            return 0;
                        case 'bottom':
                            return this.canvasHeight;
                        default:
                            throw new Error(`Unknown identifier: ${identifier}`);
                    }
                }

                if (this.match(TokenType.OPERATOR, '(')) {
                    const expr = this.parseExpression();
                    this.consume(TokenType.OPERATOR, ')');
                    return expr;
                }

				console.error('tokens', this.tokens);
                throw new Error(`Unexpected token: ${this.peek()?.value}`);
            }

            // match(...types) {
            //     for (const type of types) {
            //         if (typeof type === 'string') {
            //             if (this.check(TokenType.OPERATOR, type) || this.check(TokenType.PUNCTUATION, type)) {
            //                 this.advance();
            //                 return true;
            //             }
            //         } else {
            //             if (this.check(type)) {
            //                 this.advance();
            //                 return true;
            //             }
            //         }
            //     }
            //     return false;
            // }

			match(type, value = null) {
				if(this.check(type, value)) {
					this.advance();
					return true;
				}
				return false;
			}

            check(type, value = null) {
                if (this.isAtEnd()) return false;
                const token = this.peek();
                return token.type === type && (value === null || token.value === value);
            }

            advance() {
                if (!this.isAtEnd()) this.current++;
                return this.previous();
            }

            isAtEnd() {
                return this.peek().type === TokenType.EOF;
            }

            peek() {
                return this.tokens[this.current];
            }

            previous() {
                return this.tokens[this.current - 1];
            }

            consume(type, value = null) {
                if (this.check(type, value)) {
                    return this.advance();
                }
                throw new Error(`Expected ${type}${value ? ` '${value}'` : ''}, got ${this.peek()?.value}`);
            }
        }

        // Enhanced DSL Parser
        class AdvancedCanvasLayoutParser {
            constructor() {
                this.tokens = [];
                this.current = 0;
                this.variables = {};
                this.canvasWidth = 800;
                this.canvasHeight = 600;
            }

            parse(input) {
                const tokenizer = new Tokenizer(input);
                this.tokens = tokenizer.tokenize();
                this.current = 0;
                this.variables = {};
                
                // Parse variable declarations first
                this.parseVariableDeclarations();
                
                // Parse canvas
                return this.parseCanvas();
            }

            parseVariableDeclarations() {
                while (this.peek() && this.peek().type === TokenType.VARIABLE) {
                    this.parseVariableDeclaration();
                }
            }

            parseVariableDeclaration() {
                const varToken = this.consume(TokenType.VARIABLE);
                const varName = varToken.value;
                this.consume(TokenType.PUNCTUATION, '=');
                
                const value = this.parseExpressionValue();
                this.variables[varName] = value;
            }

            parseExpressionValue() {
                const exprTokens = [];
                let parenCount = 0;
                
                while (this.peek() && this.peek().type !== TokenType.EOF) {
                    const token = this.peek();
                    
                    // Check if this token is valid for expressions
                    const isValidExpressionToken = 
                        token.type === TokenType.NUMBER ||
                        token.type === TokenType.VARIABLE ||
                        (token.type === TokenType.IDENTIFIER && ['center', 'left', 'right', 'top', 'bottom'].includes(token.value)) ||
                        (token.type === TokenType.OPERATOR && ['+', '-', '*', '/', '(', ')'].includes(token.value));
                    
                    if (!isValidExpressionToken && parenCount === 0) {
                        break;
                    }
                    
                    if (token.type === TokenType.VARIABLE && parenCount === 0) {
                        // Check if this is the start of a new variable declaration
                        if (this.tokens[this.current + 1]?.type === TokenType.PUNCTUATION && 
                            this.tokens[this.current + 1]?.value === '=') {
                            break;
                        }
                    }
                    
                    if (token.type === TokenType.IDENTIFIER && parenCount === 0) {
                        // Check if this is the start of canvas declaration or other keywords
                        if (['canvas', 'layer', 'sprite', 'text', 'rect', 'image', 'at', 'size', 'color', 'font', 'src', 'stroke', 'animate'].includes(token.value)) {
                            break;
                        }
                    }
                    
                    if (token.type === TokenType.OPERATOR && token.value === '(') {
                        parenCount++;
                    } else if (token.type === TokenType.OPERATOR && token.value === ')') {
                        parenCount--;
                    }
                    
                    exprTokens.push(this.advance());
                    
                    if (parenCount < 0) {
                        break;
                    }
                }
                
                const exprParser = new ExpressionParser(exprTokens.concat([{ type: TokenType.EOF }]), this.variables);
                exprParser.setCanvasSize(this.canvasWidth, this.canvasHeight);
                return exprParser.parseExpression();
            }

            peek() {
                return this.tokens[this.current];
            }

            advance() {
                if (!this.isAtEnd()) this.current++;
                return this.previous();
            }

            previous() {
                return this.tokens[this.current - 1];
            }

            isAtEnd() {
                return !this.peek() || this.peek().type === TokenType.EOF;
            }

            consume(type, value = null) {
                const token = this.peek();
                if (token && token.type === type && (value === null || token.value === value)) {
                    return this.advance();
                }
                throw new Error(`Expected ${type}${value ? ` '${value}'` : ''}, got ${token?.value} at line ${token?.line}`);
            }

            parseCanvas() {
                this.consume(TokenType.IDENTIFIER, 'canvas');
                
                const width = this.parseExpressionValue();
                this.consume(TokenType.IDENTIFIER, 'x');
                const height = this.parseExpressionValue();
                
                this.canvasWidth = width;
                this.canvasHeight = height;
                
                this.consume(TokenType.PUNCTUATION, '{');
                
                const layers = [];
                const elements = [];
                
                while (this.peek() && this.peek().value !== '}') {
                    if (this.peek().value === 'layer') {
                        layers.push(this.parseLayer());
                    } else {
                        elements.push(this.parseElement());
                    }
                }
                
                this.consume(TokenType.PUNCTUATION, '}');
                
                return {
                    type: 'canvas',
                    width,
                    height,
                    layers,
                    elements
                };
            }

            parseLayer() {
                this.consume(TokenType.IDENTIFIER, 'layer');
                const name = this.consume(TokenType.IDENTIFIER).value;
                this.consume(TokenType.PUNCTUATION, '{');
                
                const elements = [];
                while (this.peek() && this.peek().value !== '}') {
                    elements.push(this.parseElement());
                }
                
                this.consume(TokenType.PUNCTUATION, '}');
                
                return {
                    type: 'layer',
                    name,
                    elements
                };
            }

            parseElement() {
                const type = this.consume(TokenType.IDENTIFIER).value;
                
                switch (type) {
                    case 'sprite':
                        return this.parseSprite();
                    case 'text':
                        return this.parseText();
                    case 'rect':
                        return this.parseRect();
                    case 'image':
                        return this.parseImage();
                    default:
                        throw new Error(`Unknown element type: ${type}`);
                }
            }

            parseSprite() {
                const name = this.consume(TokenType.IDENTIFIER).value;
                this.consume(TokenType.IDENTIFIER, 'at');
                const position = this.parsePosition();
                this.consume(TokenType.IDENTIFIER, 'size');
                const size = this.parseSize();
                this.consume(TokenType.IDENTIFIER, 'color');
                const color = this.parseColor();
                
                const sprite = {
                    type: 'sprite',
                    name,
                    x: position.x,
                    y: position.y,
                    width: size.width,
                    height: size.height,
                    color,
                    animations: []
                };
                
                while (this.peek() && this.peek().value === 'animate') {
                    sprite.animations.push(this.parseAnimation());
                }
                
                return sprite;
            }

           parseText() {
                const text = this.consume(TokenType.STRING).value.replace(/"/g, '');
                this.consume(TokenType.IDENTIFIER, 'at');
                const position = this.parsePosition();

                this.consume(TokenType.IDENTIFIER, 'font');
                const font = this.consume(TokenType.NUMBER).value;
                const fontUnit = this.consume(TokenType.IDENTIFIER).value;

                this.consume(TokenType.IDENTIFIER, 'color');
                const color = this.parseColor();
                
                const textElement = {
                    type: 'text',
                    text,
                    x: position.x,
                    y: position.y,
                    font: font+fontUnit,
                    color,
                    animations: []
                };
                
                while (this.peek() && this.peek().value === 'animate') {
                    textElement.animations.push(this.parseAnimation());
                }
                
                return textElement;
            }

            parseRect() {
                const name = this.consume(TokenType.IDENTIFIER).value;
                this.consume(TokenType.IDENTIFIER, 'at');
                const position = this.parsePosition();
                this.consume(TokenType.IDENTIFIER, 'size');
                const size = this.parseSize();
                this.consume(TokenType.IDENTIFIER, 'color');
                const color = this.parseColor();
                
                const rect = {
                    type: 'rect',
                    name,
                    x: position.x,
                    y: position.y,
                    width: size.width,
                    height: size.height,
                    color,
                    stroke: null,
                    animations: []
                };
                
                // Optional stroke
                if (this.peek() && this.peek().value === 'stroke') {
                    this.consume(TokenType.IDENTIFIER, 'stroke');
                    rect.stroke = this.parseColor();
                }
                
                while (this.peek() && this.peek().value === 'animate') {
                    rect.animations.push(this.parseAnimation());
                }
                
                return rect;
            }

            parseImage() {
                const name = this.consume(TokenType.IDENTIFIER).value;
                this.consume(TokenType.IDENTIFIER, 'at');
                const position = this.parsePosition();
                this.consume(TokenType.IDENTIFIER, 'size');
                const size = this.parseSize();
                this.consume(TokenType.IDENTIFIER, 'src');
                const src = this.consume(TokenType.STRING).value.replace(/"/g, '');
                
                const image = {
                    type: 'image',
                    name,
                    x: position.x,
                    y: position.y,
                    width: size.width,
                    height: size.height,
                    src,
                    animations: []
                };
                
                while (this.peek() && this.peek().value === 'animate') {
                    image.animations.push(this.parseAnimation());
                }
                
                return image;
            }

            parsePosition() {
                const x = this.parseExpressionValue();
                this.consume(TokenType.PUNCTUATION, ',');
                const y = this.parseExpressionValue();
                return { x, y };
            }

            parseSize() {
                const width = this.parseExpressionValue();
                this.consume(TokenType.IDENTIFIER, 'x');
                const height = this.parseExpressionValue();
                return { width, height };
            }

            parseColor() {
                const token = this.peek();
                if (token.type === TokenType.COLOR) {
                    return this.advance().value;
                }
                throw new Error(`Expected color, got ${token.value}`);
            }

            parseAnimation() {
                this.consume(TokenType.IDENTIFIER, 'animate');
                const type = this.consume(TokenType.IDENTIFIER).value;
                
                const animation = { type };
                
                switch (type) {
                    case 'move':
                        this.consume(TokenType.IDENTIFIER, 'from');
                        const fromX = this.parseExpressionValue();
                        this.consume(TokenType.PUNCTUATION, ',');
                        const fromY = this.parseExpressionValue();
                        this.consume(TokenType.IDENTIFIER, 'to');
                        const toX = this.parseExpressionValue();
                        this.consume(TokenType.PUNCTUATION, ',');
                        const toY = this.parseExpressionValue();
                        
                        animation.fromX = fromX;
                        animation.fromY = fromY;
                        animation.toX = toX;
                        animation.toY = toY;
                        break;
                        
                    case 'fade':
                        this.consume(TokenType.IDENTIFIER, 'from');
                        animation.from = this.parseExpressionValue();
                        this.consume(TokenType.IDENTIFIER, 'to');
                        animation.to = this.parseExpressionValue();
                        break;
                        
                    case 'rotate':
                        this.consume(TokenType.IDENTIFIER, 'from');
                        animation.from = this.parseExpressionValue();
                        this.consume(TokenType.IDENTIFIER, 'to');
                        animation.to = this.parseExpressionValue();
                        break;
                        
                    case 'scale':
                        this.consume(TokenType.IDENTIFIER, 'from');
                        animation.from = this.parseExpressionValue();
                        this.consume(TokenType.IDENTIFIER, 'to');
                        animation.to = this.parseExpressionValue();
                        break;
                        
                    case 'bounce':
                        this.consume(TokenType.IDENTIFIER, 'amplitude');
                        animation.amplitude = this.parseExpressionValue();
                        break;
                        
                    case 'pulse':
                        this.consume(TokenType.IDENTIFIER, 'from');
                        animation.from = this.parseExpressionValue();
                        this.consume(TokenType.IDENTIFIER, 'to');
                        animation.to = this.parseExpressionValue();
                        break;
                }
                
                this.consume(TokenType.IDENTIFIER, 'duration');
                const durationToken = this.consume(TokenType.NUMBER);
				const unitStr = this.consume(TokenType.IDENTIFIER);
                animation.duration = parseFloat(durationToken.value) * 1000; // Convert to milliseconds
                
                // Optional modifiers
                while (this.peek() && (this.peek().value === 'repeat' || this.peek().value === 'alternate')) {
                    const modifier = this.advance().value;
                    animation[modifier] = true;
                }
                
                return animation;
            }
        }

        // Renderer
        class CanvasRenderer {
            constructor(canvas) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.scene = null;
                this.animations = [];
                this.isPlaying = false;
                this.lastTime = 0;
            }

            render(scene) {
                this.scene = scene;
                this.canvas.width = scene.width;
                this.canvas.height = scene.height;
                this.setupAnimations();
                this.draw();
            }

            setupAnimations() {
                this.animations = [];
                
                const addAnimations = (elements) => {
                    elements.forEach(element => {
                        if (element.animations) {
                            element.animations.forEach(anim => {
                                this.animations.push({
                                    element,
                                    animation: anim,
                                    startTime: 0,
                                    progress: 0
                                });
                            });
                        }
                        if (element.elements) {
                            addAnimations(element.elements);
                        }
                    });
                };
                
                if (this.scene.layers) {
                    this.scene.layers.forEach(layer => addAnimations(layer.elements));
                }
                if (this.scene.elements) {
                    addAnimations(this.scene.elements);
                }
            }

            draw(timestamp = 0) {
                if (this.isPlaying) {
                    const deltaTime = timestamp - this.lastTime;
                    this.updateAnimations(timestamp, deltaTime);
                }
                this.lastTime = timestamp;

                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                if (this.scene.layers) {
                    this.scene.layers.forEach(layer => this.drawElements(layer.elements, timestamp));
                }
                if (this.scene.elements) {
                    this.drawElements(this.scene.elements, timestamp);
                }
                
                if (this.isPlaying) {
                    requestAnimationFrame((t) => this.draw(t));
                }
            }

            updateAnimations(timestamp, deltaTime) {
                this.animations.forEach(animData => {
                    const { animation } = animData;
                    
                    if (animData.startTime === 0) {
                        animData.startTime = timestamp;
                    }
                    
                    const elapsed = timestamp - animData.startTime;
                    let progress = Math.min(elapsed / animation.duration, 1);
                    
                    if (animation.alternate) {
                        progress = Math.sin(progress * Math.PI);
                    }
                    
                    if (animation.repeat && elapsed >= animation.duration) {
                        animData.startTime = timestamp;
                    }
                    
                    animData.progress = progress;
                });
            }

            drawElements(elements, timestamp) {
                elements.forEach(element => this.drawElement(element, timestamp));
            }

            drawElement(element, timestamp) {
                this.ctx.save();
                
                // Apply animations
                const elementAnimations = this.animations.filter(a => a.element === element);
                let x = element.x;
                let y = element.y;
                let alpha = 1;
                let rotation = 0;
                let scaleX = 1;
                let scaleY = 1;
                
                elementAnimations.forEach(animData => {
                    const { animation, progress } = animData;
                    
                    switch (animation.type) {
                        case 'move':
                            x = animation.fromX + (animation.toX - animation.fromX) * progress;
                            y = animation.fromY + (animation.toY - animation.fromY) * progress;
                            break;
                        case 'fade':
                            alpha = animation.from + (animation.to - animation.from) * progress;
                            break;
                        case 'rotate':
                            rotation = animation.from + (animation.to - animation.from) * progress;
                            break;
                        case 'scale':
                            scaleX = scaleY = animation.from + (animation.to - animation.from) * progress;
                            break;
                        case 'bounce':
                            y = element.y + Math.sin(progress * Math.PI * 4) * animation.amplitude;
                            break;
                        case 'pulse':
                            const pulseScale = animation.from + (animation.to - animation.from) * progress;
                            scaleX = scaleY = pulseScale;
                            break;
                    }
                });
                
                this.ctx.globalAlpha = alpha;
                this.ctx.translate(x + element.width / 2, y + element.height / 2);
                this.ctx.rotate(rotation * Math.PI / 180);
                this.ctx.scale(scaleX, scaleY);
                this.ctx.translate(-element.width / 2, -element.height / 2);
                
                switch (element.type) {
                    case 'sprite':
                    case 'rect':
                        this.ctx.fillStyle = element.color;
                        this.ctx.fillRect(0, 0, element.width, element.height);
                        if (element.stroke) {
                            this.ctx.strokeStyle = element.stroke;
                            this.ctx.strokeRect(0, 0, element.width, element.height);
                        }
                        break;
                    case 'text':
                        this.ctx.fillStyle = element.color;
                        this.ctx.font = element.font+" Arial";
                        this.ctx.textAlign = 'left';
                        this.ctx.textBaseline = 'top';
                        this.ctx.fillText(element.text, element.x, element.y);
                        break;
                    case 'image':
                        // Image loading would be handled here
                        this.ctx.fillStyle = '#ddd';
                        this.ctx.fillRect(0, 0, element.width, element.height);
                        this.ctx.fillStyle = '#999';
                        this.ctx.font = '14px sans-serif';
                        this.ctx.textAlign = 'center';
                        this.ctx.textBaseline = 'middle';
                        this.ctx.fillText('Image', element.width / 2, element.height / 2);
                        break;
                }
                
                this.ctx.restore();
            }

            play() {
                this.isPlaying = true;
                this.lastTime = 0;
                this.animations.forEach(anim => anim.startTime = 0);
                requestAnimationFrame((t) => this.draw(t));
            }

            pause() {
                this.isPlaying = false;
            }
        }

        // Global variables
        let parser, renderer;
        let isPlaying = false;

        function init() {
            parser = new AdvancedCanvasLayoutParser();
            renderer = new CanvasRenderer(document.getElementById('canvas'));
        }

        function parseAndRender() {
            const input = document.getElementById('dslInput').value;
            const parsedOutput = document.getElementById('parsedOutput');
            const messages = document.getElementById('messages');
            
            try {
                const scene = parser.parse(input);
                parsedOutput.value = JSON.stringify(scene, null, 2);
                renderer.render(scene);
                
                messages.innerHTML = '<div class="success">✓ Scene parsed and rendered successfully!</div>';
            } catch (error) {
                messages.innerHTML = `<div class="error">✗ Error: ${error.message}</div>`;
                console.error(error);
            }
        }

        function toggleAnimation() {
            const playBtn = document.getElementById('playBtn');
            
            if (isPlaying) {
                renderer.pause();
                playBtn.textContent = '▶ Play Animation';
                playBtn.className = 'play-btn';
                isPlaying = false;
            } else {
                renderer.play();
                playBtn.textContent = '⏸ Pause Animation';
                playBtn.className = 'pause-btn';
                isPlaying = true;
            }
        }

        function loadExample(num) {
            const examples = {
                1: `// Game Scene Example
$screenWidth = 800
$screenHeight = 600
$playerStartX = $screenWidth / 4
$enemyStartX = $screenWidth - 100

canvas $screenWidth x $screenHeight {
  layer background {
    rect sky at 0, 0 size $screenWidth x 300 color #87ceeb
    rect ground at 0, 300 size $screenWidth x ($screenHeight - 300) color #90ee90
  }
 
  layer entities {
    sprite player at $playerStartX, 400 size 32 x 32 color #ff6b6b
      animate move from $playerStartX, 400 to ($playerStartX + 200), 400 duration 3s repeat
      animate bounce amplitude 5 duration 1s repeat
   
    sprite enemy at $enemyStartX, 350 size 24 x 24 color #ff8e53
      animate rotate from 0 to 360 duration 2s repeat
      animate move from $enemyStartX, 350 to ($enemyStartX - 300), 350 duration 4s repeat alternate
  }
 
  layer ui {
    rect panel at 10, 10 size 200 x 80 color rgba(0,0,0,0.7) stroke #fff
    text "Health: 100%" at 20, 35 font 14px color #00ff00
    text "Score: 1250" at 20, 55 font 14px color #ffff00
  }
}`,
                2: `// UI Layout Example
$panelWidth = 300
$panelHeight = 200
$centerX = 400
$centerY = 300

canvas 800 x 600 {
  layer background {
    rect bg at 0, 0 size 800 x 600 color #2c3e50
  }
  
  layer interface {
    rect mainPanel at ($centerX - $panelWidth/2), ($centerY - $panelHeight/2) size $panelWidth x $panelHeight color #34495e stroke #ecf0f1
      animate pulse from 1 to 1.05 duration 2s repeat alternate
    
    text "Settings Panel" at $centerX, ($centerY - 80) font 24px color #ecf0f1
    text "Volume: 75%" at ($centerX - 100), ($centerY - 20) font 16px color #bdc3c7
    text "Graphics: High" at ($centerX - 100), $centerY font 16px color #bdc3c7
    text "Controls: WASD" at ($centerX - 100), ($centerY + 20) font 16px color #bdc3c7
  }
}`,
                3: `// Complex Animation Example
$radius = 150
$centerX = 400
$centerY = 300

canvas 800 x 600 {
  layer background {
    rect bg at 0, 0 size 800 x 600 color #1a1a2e
  }
  
  layer effects {
    sprite orb1 at ($centerX + $radius), $centerY size 20 x 20 color #ff6b6b
      animate move from ($centerX + $radius), $centerY to ($centerX - $radius), $centerY duration 2s repeat alternate
      animate fade from 0.3 to 1 duration 1s repeat alternate
      animate scale from 0.8 to 1.2 duration 1.5s repeat alternate
    
    sprite orb2 at $centerX, ($centerY - $radius) size 15 x 15 color #4ecdc4
      animate move from $centerX, ($centerY - $radius) to $centerX, ($centerY + $radius) duration 2.5s repeat alternate
      animate rotate from 0 to 360 duration 3s repeat
      
    sprite orb3 at ($centerX - $radius/2), ($centerY + $radius/2) size 18 x 18 color #ffe66d
      animate bounce amplitude 20 duration 1.2s repeat
      animate pulse from 0.5 to 1.5 duration 2s repeat alternate
      
    text "Orbital Dance" at $centerX, 100 font 32px color #f38ba8
      animate fade from 0.5 to 1 duration 3s repeat alternate
  }
}`
            };
            
            document.getElementById('dslInput').value = examples[num];
            parseAndRender();
        }

        function clearCanvas() {
            const canvas = document.getElementById('canvas');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            document.getElementById('parsedOutput').value = '';
            document.getElementById('messages').innerHTML = '';
        }

        // Initialize on page load
        document.addEventListener('DOMContentLoaded', () => {
            init();
            parseAndRender(); // Parse the default example
        });
    </script>
</body>
</html>